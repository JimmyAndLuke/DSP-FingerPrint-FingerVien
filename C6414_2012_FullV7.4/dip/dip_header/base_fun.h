/******************************************************************************
 * 文件名：base_fun.h
 * 功能：  
******************************************************************************/

#if !defined __BASE_FUN_H
#define __BASE_FUN_H

#include <stdio.h>
#include <stdlib.h>
//#include <string.h>
#include <math.h>

#ifdef __cplusplus
extern "C" {
#endif

/* 定义PI值 */
#ifndef M_PI
#define M_PI				3.1415926
#define M_EPI				57.29578		//180/M_PI
#endif

#ifndef min
#define min(a,b) (((a)<(b))?(a):(b))
#endif

#ifndef max
#define max(a,b) (((a)>(b))?(a):(b))
#endif


extern int sin_10000[91];
int get_sin_cos(int angle, int flag);

/******************************************************************************
  * 功能：指定输入的小数点后面的位数
  * 参数：number    输入的浮点数
  *       n			保留的位数
  * 返回：转换后的指定位数的浮点数
******************************************************************************/
//double my_round(double number, int n);


/******************************************************************************
  * 功能：对一维数组排序,unsigned char, unsigned int
  * 参数：value     输入数组指针
  *       length	输入数组的长度
  * 返回：返回数组的中值
  * 说明: 注意目前只支持unsigned char, unsigned int
******************************************************************************/
void my_sort(void *val, unsigned int length);


/******************************************************************************
  * 功能：对一维数组排序,double型
  * 参数：value     输入数组指针
  *       length	输入数组的长度
  * 返回：返回数组的中值
  * 说明: 注意目前只支持unsigned char, unsigned int
******************************************************************************/
void my_sort_d(void *val, unsigned int length);


/******************************************************************************
  * 功能：对一维数组排序,并返回数组的中值(unsigned char型数组)
  * 参数：value     输入数组指针
  *       length	输入数组的长度
  * 返回：返回数组的中值
  * 说明: 注意目前只支持字节
******************************************************************************/
unsigned char get_median_num(unsigned char *value, unsigned int length);


/******************************************************************************
  * 功能：对一维数组排序,并返回数组的中值(double型数组)
  * 参数：value     输入数组指针
  *       length	输入数组的长度
  * 返回：返回数组的中值
  * 说明: 
******************************************************************************/
double		  get_median_num_d(double *value, unsigned int length);


/******************************************************************************
  * 功能：对一维数组排序,并返回排序后第pos个值(double型数组)
  * 参数：value     输入数组指针
  *       length	输入数组的长度
  *		  pos		排序后pos位置(0~length-1)
  * 返回：返回数组的中值
  * 说明: 
******************************************************************************/
double get_array_num_d(double *value, unsigned int length, unsigned int pos);


/******************************************************************************
  * 功能：返回a,b中的最大者(double型数组)
  * 参数：value     输入数组指针
  *       length	输入数组的长度
  *		  pos		排序后pos位置(0~length-1)
  * 返回：
  * 说明: 
******************************************************************************/
double get_max_d(double a, double b);


/*************************************************************************
  * 功能：生成一维的高斯函数数据
  * 参数：sigma			高斯函数的标准差
  *       gauss_data	指向高斯数据数组的指针,即:归一化后的高斯系数
  *						exp(-0.5*(x-u)^2/sigma^2) /( sqrt(2*PI)*sigma)
  *		  data_len		数据的长度
  * 返回：
  * 说明: 
  *   这个函数可以生成一个一维的高斯函数的数字数据，理论上高斯数据的长度应
  *   该是无限长的，但是为了计算的简单和速度，实际的高斯数据只能是有限长的
  *   data_len就是数据长度
  *	注意: 调用此函数前,要先计算出data_len,并且为gauss_data分配好内存,如
  *		  int gauss_data_len = 2*((int)(3 * sigma) + 1) + 1;	
  *		  double *pGaussData = malloc(sizeof(double)*gauss_data_len);
  *       cal_gauss_filter_data_v1(0.4, gauss_data, gauss_data_len);
  *       ...
  *       free(pGaussData);
  *       ...
 **************************************************************************/
void calc_gauss_filter_data(double sigma, double *gauss_data, int data_len);


/*************************************************************************
  * 功能：生成一维的高斯函数数据
  * 参数：sigma			高斯函数的标准差
  *       gauss_data	指向高斯数据数组的指针,即:归一化后的高斯系数
  *						exp(-0.5*(x-u)^2/sigma^2) /( sqrt(2*PI)*sigma)
  *		  data_len		数据的长度
  * 返回：
  * 说明: 
  *   这个函数可以生成一个一维的高斯函数的数字数据，理论上高斯数据的长度应
  *   该是无限长的，但是为了计算的简单和速度，实际的高斯数据只能是有限长的
  *   data_len就是数据长度
  *	注意: 调用此函数前,要先计算出data_len,并且为gauss_data是一个指向数组的
  *		  指针(即指针的指针),在使用完之后,要记得释放,如
  *		  double *pGaussData;
  *		  int gauss_data_len;
  *       cal_gauss_filter_data_v1(0.4, &gauss_data, &gauss_data_len);
  *       ...
  *       free(pGaussData);
  *       ...
 **************************************************************************/
void calc_gauss_filter_data_v1(double sigma, double **gauss_data, int *data_len);


//
//	GetAngle90In180: 求两个角度的夹角(0 - 90)
//	
/////////////////////////////////////////////////////////////////////////
//	angle1: [in] 角度一(0 - 180)
//	angle2: [in] 角度二(0 - 180)
/////////////////////////////////////////////////////////////////////////
int  GetAngle90In180(int angle1, int angle2);


//
//	GetAngle180In360: 求两个角度的夹角(0 - 180)
//
/////////////////////////////////////////////////////////////////////////
//	angle1: [in] 角度一(0 - 360)
//	angle2: [in] 角度二(0 - 360)
/////////////////////////////////////////////////////////////////////////
int  GetAngle180In360(int angle1, int angle2);


//
//	GetAngle360In360： 两个角度间的距离(0-360)  (逆时针方向)
//
/////////////////////////////////////////////////////////////////////////
//	angleBegin: [in] 起始角度(0-360)
//	angleEnd: [in] 终结角度(0-360)
/////////////////////////////////////////////////////////////////////////
int  GetAngle360In360(int angleBegin, int angleEnd);


//
//	XY2Angle： 两个点连线与x轴方向的角度
//
/////////////////////////////////////////////////////////////////////////
//	x0: [in] 第一个点横坐标
//	y0: [in] 第一个点纵坐标
//	x1: [in] 第二个点横坐标
//	y1: [in] 第二个点纵坐标
/////////////////////////////////////////////////////////////////////////
int  XY2Angle(int x0, int y0, int x1, int y1);


/******************************************************************************
  * 功能：数据拷贝
  * 参数：pDst		数据拷贝目标区域
  *       pSrc		数据拷贝源区域
  *		  size		拷贝大小
  * 返回：
******************************************************************************/
void BufferCopy(unsigned char *pDst, unsigned char *pSrc, unsigned int size);



#ifdef __cplusplus
}
#endif /* extern "C" */

#endif /* __BASE_FUN_H */

