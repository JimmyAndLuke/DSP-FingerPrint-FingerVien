/******************************************************************************
 * 文件名：image_miscellaneous.h
 * 功  能：一些基本的图像操作
******************************************************************************/

#if !defined __IMAGE_MISCELLANEOUS_H
#define __IMAGE_MISCELLANEOUS_H

//#include "image.h"
#include "../../bsp/bsp_header/z_mytype.h"

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************
  * 功能：对骨架图像进行扫描并标记
  * 参数：p         指向源图像数据区
  *       pitch     每像素所占字节数
  *       x         端点x坐标(种子点x坐标)
  *		  y         端点y坐标(种子点y坐标)
  *       part_num  当前扫描块的编号
  *       part_area 用来记录联通区域大小的计数器
  *       area_thr  用来判断终止条件的,当计数器的值大于阈值area_thr时则终止当前扫描
  * 返回：void
  * 说明: 输入图像数据为二值数据(0,1),且图像是骨骼化后的
  *       输入的(x,y)坐标是骨骼化图像的端点坐标
  * 算法: 
  *       1.从输入的种子点坐标(x,y)开始进行扫描,
  *       2.计算种子点8邻域和连通面积记录并进行如下:
  *         (1)超出连通面积的终止条件area_thr
  *         (2)是端点
  *			(3)挨着交叉点的点
  *         (4)种子点是交叉点
  *         如果满足上面的要求,则退出迭代,否则,进入3
  *       3.寻找下一个方向,并将此方向的点作为下一个种子点,返回步骤1
  *       4.不断迭代,直到终止条件.(终止条件为2中的几个条件)
*************************************************************************/
void SkeletonBurrMarkOZ
	(
	uint8_t *p,
	const int32_t pitch,
	const int32_t   x,
	const int32_t   y,
	const int32_t   part_num, //连通区域的编号
	uint8_t *part_area,  //返回值，记录联通区域的大小
	const int32_t   area_thr
	);

/************************************************************************
  * 功能：对扫描标记后的骨架图像进行清除毛刺
  * 参数：p         指向源图像数据区
  *       w         图像宽度
  *		  h         图像高度
  *       pitch     每像素所占字节数
  *       part_area 用来记录联通区域大小的计数器
  *       area_thr  用来判断终止条件的,当计数器的值大于阈值area_thr时则终止当前扫描
  * 返回：void
  * 说明: 输入图像数据为二值数据(0,1),且图像是骨骼化后的
  *       输入的(x,y)坐标是骨骼化图像的端点坐标
*************************************************************************/
void SkeletonBurrClearOZ
	(
	uint8_t *p,
	const int32_t   w,
	const int32_t   h,
	const int32_t   pitch,
	uint8_t *part_area,
	const int32_t   area_thr 
	);


/************************************************************************
  * 功能：清除图像孤立点
  * 参数：p         指向源图像数据区
  *       w         图像宽度
  *		  h         图像高度
  * 返回：void
  * 说明: 输入图像数据为二值数据(0,1)
*************************************************************************/
void RemoveAcnode
	(
	uint8_t *p,
	const int32_t   w,
	const int32_t   h,
	const int32_t   pitch
	);


/******************************************************************************
  * 功能：4邻域连通区域填充
  * 参数：pSrc			图像数据指针(图像为二值图像)
  *       width			输入图像宽度
  *       height			输入图像高度
  *       pitch			输入图像每行字节个数
  *       x				种子点x坐标
  *       y				种子点y坐标
  *       end_area		判断终止条件,为0时完全填充,其他值时,若>end_area就停止填充
  *       mark_gary		使用此值标记生长区域的灰度值
  * 返回：填充区域的面积
  * 说明: 图像为二值图像,但不一定要是0,1二值
  * 算法:
  *       1.先判断(x,y)坐标颜色类型是否为color_type且是否已填充为mark_gary,
  *         是退出,否进入步骤2
  *       2.从第i=y行开始,自左向右(j=0~width)做个像素进行扫描,判断扫描的
  *		  当前点是否已填充为mark_gary,若不是,继续步骤2,扫描下一点.若是,进入步骤3
  *       3.判断当前的4邻域内是否有点与种子点是同一类型(temp_color)且没有标记,若否
  *         进入步骤2.若是进入步骤4
  *       4.标记4邻域的点为mark_gray,且区域面积++.同时判断4邻域的点是否在第i行前,
  *         若否,什么不做.若是,更新yMin和bNew标记.在本行i扫描完毕后,使i=yMin-1.
******************************************************************************/
int32_t FourNeighbor
(
 uint8_t *pSrc,
 const int32_t width,
 const int32_t height,
 const int32_t pitch,
 const int32_t x,
 const int32_t y,
 const int32_t color_type,
 const int32_t end_area,
 const uint8_t mark_gray
 );


/******************************************************************************
  * 功能：图像数据连通区域标记
  * 参数：
  *		  pSrc			图像数据指针(图像为二值图像)
  *		  region_num	连通区域编号数组(数组的元素值对应改编号区域大小)
  *       width			输入图像宽度
  *       height		输入图像高度
  *       pitch			输入图像每行字节个数
  * 返回：
  * 说明: 标记的区域编号从2开始,其中原图数据为0的值变为偶数编号(2,4,...)
  *		  原图数据为1的值变为奇数编号(3,5,...)
  *		  一般根据最后region_num调用RegionAreaFilter函数进行小区域去噪处理
  * 算法: 1.对图像数据自左向右,自上向下逐点扫描并调用8邻域(4邻域)填充函数进行标记
  *		  2.根据标记值对图像数据自左向右,自上向下逐点扫描并记录到region_num数组中
******************************************************************************/
void RegionMarkOZ
(
 uint8_t *pSrc,
 int32_t *region_num,
 const int32_t width, 
 const int32_t height, 
 const int32_t pitch
 );


/******************************************************************************
  * 功能：图像数据区域去噪处理
  * 参数：
  *		  pSrc			经过标记的图像数据
  *		  region_num	连通区域编号数组(数组的元素值对应改编号区域大小)
  *		  fore_area_thr	前景色区域阈值
  *		  back_area_thr	背景色区域阈值
  *       width			输入图像宽度
  *       height		输入图像高度
  *       pitch			输入图像每行字节个数
  * 返回：
  * 说明: 
******************************************************************************/
void RegionAreaFilter
(
 uint8_t *pSrc,
 int32_t *region_num,
 const int32_t fore_area_thr,
 const int32_t back_area_thr,
 const int32_t width, 
 const int32_t height, 
 const int32_t pitch 
 );



/******************************************************************************
*******************************************************************************
************************下面的函数对指纹具有较强的适用性***********************
************************下面的函数对指纹具有较强的适用性***********************
************************下面的函数对指纹具有较强的适用性***********************
*******************************************************************************
******************************************************************************/


/************************************************************************
  * 功能：寻找当前点的下一有效点,被SkeletonBurrClearV1等调用
  * 参数：pNow				当前点的地址[In]
  *		  width				前驱点的地址[In]
  *		  ppNext			下一个点的地址的指针[Out]
  *		  width				图像数据宽度
  *		  height			图像数据高度
  *		  pitch				图像数据每行字节数
  *		  forecolor		    图像数据前景颜色
  *		  backcolor		    图像数据背景颜色
  * 返回：0:正确找到.1:没找到或找到多个
  * 说明: 被SkeletonBurrClearV1调用,被image_feature中的很多函数调用
*************************************************************************/
int32_t GetNext
(
 uint8_t *pNow, 
 uint8_t *pLast, 
 uint8_t **ppNext, 
 //const int32_t width, 
 //const int32_t height, 
 const int32_t pitch,
 const int32_t forecolor
);


/************************************************************************
  * 功能：判断所在点是否为交叉点,被SkeletonBurrClearV1等调用
  * 参数：pNow				当前点的地址[In]
  *		  width				图像数据宽度
  *		  height			图像数据高度
  *		  pitch				图像数据每行字节数
  *		  bina_type			图像二值类型1:(0,1)或其他:(0,255)
  * 返回：若为交叉点,返回1.	其他返回0
  * 说明: 被SkeletonBurrClearV1调用,被image_feature中的很多函数调用
*************************************************************************/
int32_t IsFork
(
 uint8_t *pNow, 
 //const int32_t width, 
 //const int32_t height, 
 const int32_t pitch,
 const int32_t bina_type
);


/************************************************************************
  * 功能：判断所在点是否为端点,被SkeletonBurrClearV1等调用
  * 参数：pNow				细化后图像的当前点的地址[In]
  *		  width				图像数据宽度
  *		  height			图像数据高度
  *		  pitch				图像数据每行字节数
  *		  bina_type			图像二值类型1:(0,1)或其他:(0,255)
  * 返回：若为交叉点,返回1.	其他返回0
  * 说明: 被SkeletonBurrClearV1调用,被image_feature中的很多函数调用
*************************************************************************/
int32_t IsEnd
(
 uint8_t *pNow, 
 //const int32_t width, 
 //const int32_t height, 
 const int32_t pitch,
 const int32_t bina_type
);


/************************************************************************
  * 功能：沿纹线跟踪找到距离当前点距离为dis的点,返回其地址
  * 参数：pPoint			细化后图像的当前点的地址[In]
  *		  ppPos				距离当前点dis的点的地址的指针[Out]
  *		  dis				跟踪距离(像素点点数)
  *		  width				图像数据宽度
  *		  height			图像数据高度
  *		  pitch				图像数据每行字节数
  *		  forecolor		    图像数据前景颜色
  *		  backcolor		    图像数据背景颜色
  * 返回：若找到返回0, 错误:返回1
  * 说明: 被image_feature中的很多函数调用
*************************************************************************/
int32_t  GetPointByDis
(
 uint8_t *pPoint, 
 uint8_t **ppPos, 
 int32_t dis,
 //const int32_t width, 
 //const int32_t height, 
 const int32_t pitch,
 const int32_t forecolor,
 const int32_t bina_type
 );


/************************************************************************
  * 功能：对清除细化图像中短棒和毛刺
  * 参数：pSrc				指向源图像数据区
  *		  area_thr			短棒和毛刺的最大长度
  *		  width				图像数据宽度
  *		  height			图像数据高度
  *		  pitch				图像数据每行字节数
  *		  forecolor		    图像数据前景颜色
  *		  backcolor		    图像数据背景颜色
  *		  bina_type			图像二值类型1:(0,1)或其他:(0,255)
  * 返回：void
  * 说明: 利用类似链表的原理,而不采用函数迭代的形式(参考SkeletonBurrMarkOZ)
  *	算法: 1.遍历图像的每一像素点,计算其8邻域.
  *  		(1)若为孤立的点清除为背景点,并进入步骤1继续下一点的遍历
  *			(2)若为端点,记录其邻域的某个的为新的点,并进入步骤2
  *		  2.由此点开始扫描路径(纹线跟踪)area_thr个点.
  *		    (1)若此点遇到叉点(调用IsFork函数判断),直接结束此次跟踪,进入步骤4
  *			(2)记录此点地址,并找寻下一点(调用GetNext),
  *			   若找到下一点,继续进行步骤2.
  *			   如果找不到下一点,则进入步骤3.
  *			   或者扫描路径超过area_thr.进入步骤4
  *		  3.将刚才扫描过的路径清除为背景点
  *		  4.遍历下一个像素点,直到全部点遍历完毕.
  * 注意:输入图像数据为二值数据(0,1)或(0,255),且前景色必须为0???
*************************************************************************/
void SkeletonBurrClearV1
(
 uint8_t *pSrc, 
 const int32_t area_thr, 
 const int32_t width, 
 const int32_t height, 
 const int32_t pitch,
 const int32_t forecolor,
 const int32_t backcolor,
 const int32_t bina_type
);











#ifdef __cplusplus
}
#endif	/* extern "C" */

#endif /* __IMAGE_MISCELLANEOUS_H */


