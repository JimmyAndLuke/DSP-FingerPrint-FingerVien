/******************************************************************************
 * 文件名：image_binary.h
 * 功  能：一些图像二值(0,1或0,255)化操作
******************************************************************************/

#if !defined __IMAGE_BINARY_H
#define __IMAGE_BINARY_H

#include "image.h"
#include "image_enhance_filter.h"

#ifdef __cplusplus
extern "C" {
#endif


//OZ{1(one) 0(zero)二值化}区别于黑白(0,255)二值化

#define THR_WB			0		
#define THR_WBI			1	
#define THR_OZ			2
#define THR_OZI			3
#define THR_TRUNC		4
#define THR_ZERO		5
#define THR_ZEROI		6


/******************************************************************************
  * 功能：图像固定阈值二值化
  * 参数：image       指纹图像
  *       thr_value       阈值
  * 返回：错误编号
******************************************************************************/
FunError_t ImageBinarize(Image_t image, const uint8_t thr_value);
FunError_t ImageBinarizeOZ(Image_t image, const uint8_t thr_value);


/******************************************************************************
  * 功能：图像固定阈值操作(包含了固定阈值二值化的两个函数的功能)
  * 参数：image         图像
  *       thr_value     阈值
  *       max_value	    在某些阈值类型操作时,取得的最大值
  *       thr_type		阈值操作类型
  * 返回：错误编号
******************************************************************************/
FunError_t ImageThreshold(Image_t image, const uint8_t thr_value, const uint8_t max_value, const int32_t thr_type);

/******************************************************************************
  * 功能：图像二值化,使用图像的总体均值作为阈值
  * 参数：image     指纹图像
  *       x0		截取图像部分的开始x坐标
  *       y0		截取图像部分的开始y坐标
  *       dx		截取图像部分的宽度
  *       dy		截取图像部分的高度
  *		  dir		二值化方式
  * 返回：错误编号
  * 说明: 此处的二值仅指0和1,不是0和255,简单修改下就可以实现0和255的二值化
  *		  二值化化方式:
  *			dir == 1: >thr_value: 1, else: 0
  *			dir == 0: >thr_value: 0, else: 1 
  *			dir == 2: >thr_value: 0, else: 255
  *			dir == 3: >thr_value: 255, else: 0	
  * 算法描述:
  *		  计算出截取出来的图像的总体平均灰度作为阈值	
******************************************************************************/
FunError_t ImageOverallBinary
(
 Image_t image, 
 const int32_t x0, 
 const int32_t y0, 
 const int32_t dx,
 const int32_t dy,
 const int32_t dir
 );


/******************************************************************************
  * 功能：图像二值滤波操作，通过计算均值实现.可滤波,亦可二值化
  * 参数：image     图像
  *       size      软化窗口大小(2*r+1)
  *		  dir		二值化方式
  * 返回：错误编号
  * 说明: 此处的二值仅指0和1,不是0和255,简单修改下就可以实现0和255的二值化
  *		  二值化化方式:
  *			dir == 1: >thr_value: 1, else: 0
  *			dir == 0: >thr_value: 0, else: 1 
  *			dir == 2: >thr_value: 0, else: 255
  *			dir == 3: >thr_value: 255, else: 0	
  *       边界影响,经过这个函数处理后的图像实际上被裁剪去了size行和size列
******************************************************************************/
FunError_t ImageMeanBinary(Image_t image, const int32_t size, const int32_t dir/*, const int32_t OZ_WB*/);


/******************************************************************************
  * 功能：图像二值滤波操作，通过计算均值实现
  * 参数：image     指纹图像
  *       size      软化窗口大小(2*r+1)
  *		  dir		二值化方式
  * 返回：错误编号
  * 说明: 此处的二值仅指0和1,不是0和255,简单修改下就可以实现0和255的二值化
  *		  二值化化方式:
  *			dir == 1: >thr_value: 1, else: 0
  *			dir == 0: >thr_value: 0, else: 1 
  *			dir == 2: >thr_value: 0, else: 255
  *			dir == 3: >thr_value: 255, else: 0	
  *		  图像先进行直接延伸,在进行模版操作
  *		  因此宽,高在模版操作后没有变化
******************************************************************************/
FunError_t ImageMeanBinaryV1(Image_t image, const int32_t size, const int32_t dir/*, const int32_t OZ_WB*/);


/******************************************************************************
  * 功能：图像统计滤波操作，通过计算均值实现
  * 参数：image     图像
  *       size      软化窗口大小(2*r+1)
  *       thre_val  阈值
  *		  dir		二值化方式
  * 返回：错误编号
  * 说明: 此处的二值仅指0和1,不是0和255,简单修改下就可以实现0和255的二值化
  *		  二值化化方式:
  *			dir == 1: >thr_value: 1, else: 0
  *			dir == 0: >thr_value: 0, else: 1 
  *			dir == 2: >thr_value: 0, else: 255
  *			dir == 3: >thr_value: 255, else: 0	
  *       边界影响,经过这个函数处理后的图像实际上被裁剪去了size行和size列
******************************************************************************/
FunError_t ImageStatisticsFilter(Image_t image, const int32_t size, const int32_t thre_val, const int32_t dir/*, const int32_t OZ_WB*/);


/******************************************************************************
  * 功能：图像Niblack操作,局部动态阈值算法.可分割,亦可用来二值化
  * 参数：image     图像
  *       size      模版窗口大小(2*r+1)
  *		  ratio		Niblack修正系数
  *		  dir		二值化方式
  * 返回：错误编号
  * 说明: 此处的二值仅指0和1,不是0和255,简单修改下就可以实现0和255的二值化
  *		  二值化化方式:
  *			dir == 1: >thr_value: 1, else: 0
  *			dir == 0: >thr_value: 0, else: 1 
  *			dir == 2: >thr_value: 0, else: 255
  *			dir == 3: >thr_value: 255, else: 0	
  *       边界影响,经过这个函数处理后的图像实际上被裁剪去了size行和size列
  * 算法: 一种简单有效的局部动态阈值算法,对图像中的每一点,在rxr领域内,
  *		  计算领域内像素点的均值和方差,然后用T(x,y) = m(x,y) + k x s(x,y)
  *		  作为阈值,进行二值化.
  *		  T(x,y)为该点阈值,m(x,y)为该点rxr领域内像素的均值,s(x,y)为标准方差
  *		  k为修正系数
******************************************************************************/
FunError_t ImageNiBlack(Image_t image, const int32_t size, const double ratio, const int32_t dir);


/******************************************************************************
  * 功能：图像Otsu算法(大律法或最大类间方差法),利用阈值将原图像分成前景，背景两个图象
  * 参数：image     图像
  *       x0		截取图像部分的开始x坐标
  *       y0		截取图像部分的开始y坐标
  *       dx		截取图像部分的宽度
  *       dy		截取图像部分的高度
  *		  dir		二值化方式
  * 返回：错误编号
  * 说明: 此处的二值仅指0和1,不是0和255,简单修改下就可以实现0和255的二值化
  *		  二值化化方式:
  *			dir == 1: >thr_value: 1, else: 0
  *			dir == 0: >thr_value: 0, else: 1 
  *			dir == 2: >thr_value: 0, else: 255
  *			dir == 3: >thr_value: 255, else: 0	
  * 算法描述: 
  *       一种简单有效的局部动态阈值算法,对图像中的每一点,在rxr领域内,
  *       记t为前景与背景的分割阈值，前景点数占图像比例为w0，平均灰度为u0；
  *       背景点数 占图像比例为w1，平均灰度为u1。
  *       则图像的总平均灰度为：u=w0*u0+w1*u1
  *       前景和背景图象的方差：
  *       g=w0*(u0-u)*(u0-u)+w1*(u1-u)*(u1-u)=w0*w1*(u0-u1)*(u0-u1),此公式为方差公式
  *       可参照概率论课本上面的g的公式也就是下面程序中的sb的表达式。当方差g最大时，
  *       可以认为此时前景和背景差异最大，此时的灰度t是最佳阈值   
  *       sb = w1*w2*(u1-u0)*(u0-u1)
******************************************************************************/
FunError_t ImageOtsu
	(
	 Image_t image, 
	 const int32_t x0, 
	 const int32_t y0, 
	 const int32_t dx, 
	 const int32_t dy,
	 const int32_t dir
	 );

//进行两次Otsu计算,第一次算出阈值,然后再在此阈值
//基础上进行新的一次Otsu计算
FunError_t ImageOtsuV1
	(
	 Image_t image, 
	 const int32_t x0, 
	 const int32_t y0, 
	 const int32_t dx, 
	 const int32_t dy,
	 const int32_t dir
	 );




/******************************************************************************
*******************************************************************************
************************下面的函数对指纹具有较强的适用性***********************
************************下面的函数对指纹具有较强的适用性***********************
************************下面的函数对指纹具有较强的适用性***********************
*******************************************************************************
******************************************************************************/
extern int g_direction_xy[12][7][2];


/******************************************************************************
  * 功能：图像数据的基于方向的智能二值化
  * 参数：pSrc				经过前后景分割的图像的数据指针	
  *		  pOrient			经过前后景分割的方向场数据指针
  *	      pGrads			经过前后景分割的梯度幅值数据指针
  *		  width				图像宽度
  *		  height			图像高度
  *		  pitch				图像每行字节数
  *		  dir				图像二值化方向
  * 返回：错误编号
  * 说明: 此处的二值仅指0和1,不是0和255,简单修改下就可以实现0和255的二值化
  *		  二值化化方式:
  *			dir == 1: >thr_value: 1, else: 0
  *			dir == 0: >thr_value: 0, else: 1 
  *			dir == 2: >thr_value: 0, else: 255
  *			dir == 3: >thr_value: 255, else: 0	
  *       指纹图像二值化有两种方法:灰度阈值分割法(常用的阈值分割)和智能
  *		  二值化邻域分析法.
  *		  智能二值化邻域分析法:
  *			原理:位于场中的粒子必然受到场的作用.同样,指纹纹线场(方向场)中的
  *				 指纹微粒也可以看做受其作用排列,并拥有场的性质.那么,在某一
  *				 区域内,在某一个指纹微粒的切线方向上,必然是同类指纹微粒.即
  *				 在某一区域内脊上某点的切线方向上的点还是属于脊,谷也同理.
  *			分析:1.对于纹线上的黑点,沿纹线方向的附近区域应该都是黑点,其灰度
  *				   值的和较小;纹线垂直方向上附近的都是白点,其灰度值较大.
  *				 2.对于纹线上之间的白点,沿纹线方向的附近区域应该都是白点,其灰度
  *				   值的和较大;纹线垂直方向上附近的都是黑点,其灰度值较小.
  *				   由此可得:对于一个点,如果切向灰度和小于法向灰度和,判断为黑点在
  *				   脊上.反之,则为白点在谷上.
  *		    实现:1.设f(x0,y0)为该点的灰度值,其方向场为O(x0,y0),w为邻域范围
  *				   H为切向像素值之和:H = sum(f(x,x/cos(O(x0,y0))))  (x=-w/2...w/2)
  *				   V为法向像素值之和:V = sum(f(x,x/sin(O(x0,y0))))  (x=-w/2...w/2)
  *				 2.如果V>H,该点在脊上,反之,在谷上
  *				 3.实际运算中,考虑到误差因素,故在求灰度和时,对每一点都设置了权值
  *				   采用加权平均的方法来降低误差
  *				   设纹线方向七点的权值为:			Hw=1/7(2,2,3,4,3,2,2)
  *				   设纹线方向垂直方向七点的权值为:	Vw=1/7(1,1,1,1,1,1,1)
  * 算法: 
  *		  1.获得方向场数据.函数的参数pOrient即为方向场数据,因此要确保先计算
  *		    得到pOrient(调用GetOrientation获得)
  *		  2.由pOrient数据得到每点的纹线角度,并调用AngleToDirection函数获得纹线
  *		    方向
  *		  3.由纹线方向对g_direction_xy数组索引表进行索引,获得对应方向上点的坐标
  *		  4.分别利用加权滤波器Hw和Vw对纹线水平方向,垂直方向进行加权滤波
  *		  5.根据纹线和垂直于纹线等到的加权滤波值,判断图像是那种颜色.
  *	总结: 
  *       加速算法(模版大小固定7x7):
  *			  (1)为了加快速度,将Gabor函数制成模版,用模版来拟合Gabor函数,如:
  *		         这里的OrientBinary函数.
  *			  (2)又因为二维矩形模版运算也很耗时,故将矩形模版变为两条相交的
  *			     线段性模版,这样作模版运算,运算量就小很多.
  *			  (3)化简后得到的切向滤波模版是:		Hw=1/7(2,2,3,4,3,2,2)
  *							 法向滤波模版是:		Vw=1/7(1,1,1,1,1,1,1)
  *	P.S.: 函数OrientEnhance的实现与之类似
******************************************************************************/
void OrientBinary
(
 uint8_t *pSrc, 
 uint8_t *pOrientation, 
 uint8_t *pGrads,
 int32_t width, 
 int32_t height, 
 int32_t pitch, 
 int32_t dir
);


/******************************************************************************
  * 功能：利用梯度对指纹图像进行前景与背景的分割
  * 参数：image			经过前后景分割的指纹图像[Out]
  *       image_ori		经过前后景分割的方向场[In]
  *		  image_grads	经过前后景分割的梯度(用于判断像素点是前景还是背景)[In]
  *       dir			二值化方向
  * 返回：错误编号
  * 说明: 此处的二值仅指0和1,不是0和255,简单修改下就可以实现0和255的二值化
  *		  二值化化方式:
  *			dir == 1: >thr_value: 1, else: 0
  *			dir == 0: >thr_value: 0, else: 1 
  *			dir == 2: >thr_value: 0, else: 255
  *			dir == 3: >thr_value: 255, else: 0	
  *       指纹图像二值化有两种方法:灰度阈值分割法(常用的阈值分割)和智能
  *		  二值化邻域分析法.
  *		  智能二值化邻域分析法:
  *			原理:位于场中的粒子必然受到场的作用.同样,指纹纹线场(方向场)中的
  *				 指纹微粒也可以看做受其作用排列,并拥有场的性质.那么,在某一
  *				 区域内,在某一个指纹微粒的切线方向上,必然是同类指纹微粒.即
  *				 在某一区域内脊上某点的切线方向上的点还是属于脊,谷也同理.
  *			分析:1.对于纹线上的黑点,沿纹线方向的附近区域应该都是黑点,其灰度
  *				   值的和较小;纹线垂直方向上附近的都是白点,其灰度值较大.
  *				 2.对于纹线上之间的白点,沿纹线方向的附近区域应该都是白点,其灰度
  *				   值的和较大;纹线垂直方向上附近的都是黑点,其灰度值较小.
  *				   由此可得:对于一个点,如果切向灰度和小于法向灰度和,判断为黑点在
  *				   脊上.反之,则为白点在谷上.
  *		    实现:1.设f(x0,y0)为该点的灰度值,其方向场为O(x0,y0),w为邻域范围
  *				   H为切向像素值之和:H = sum(f(x,x/cos(O(x0,y0))))  (x=-w/2...w/2)
  *				   V为法向像素值之和:V = sum(f(x,x/sin(O(x0,y0))))  (x=-w/2...w/2)
  *				 2.如果V>H,该点在脊上,反之,在谷上
  *				 3.实际运算中,考虑到误差因素,故在求灰度和时,对每一点都设置了权值
  *				   采用加权平均的方法来降低误差
  *				   设纹线方向七点的权值为:			Hw=1/7(2,2,3,4,3,2,2)
  *				   设纹线方向垂直方向七点的权值为:	Vw=1/7(1,1,1,1,1,1,1)
******************************************************************************/
FunError_t ImageOrientBinary
(
 Image_t image,
 Image_t image_ori,
 Image_t image_grads,
 const int32_t dir
);



#define TOOZ  0
#define TOWB  1
/******************************************************************************
  * 功能：图像二值互换(OZ二值与黑白二值互换)
  * 参数：pSrc        图像必须为二值化后的图像数据
  * 参数：dir         从1:OZ-->WB, 0:WB-->OZ
  * 返回：错误编号
******************************************************************************/
FunError_t BinaryExchange(uint8_t *pSrc, const int32_t w, int32_t h, const int32_t dir);


/******************************************************************************
  * 功能：图像二值互换(OZ二值与黑白二值互换)
  * 参数：
  *       pSrc      图像必须为二值化后的图像数据
  *       w			图像宽度
  *       h			图像高度
  *       pitch		图像每行字节数
  *       x0		截取图像部分的开始x坐标
  *       y0		截取图像部分的开始y坐标
  *       dx		截取图像部分的宽度
  *       dy		截取图像部分的高度
  *       dir       从1:OZ-->WB, 0:WB-->OZ
  * 返回：错误编号
  * 说明: 此处的二值仅指0和1,不是0和255,简单修改下就可以实现0和255的二值化
  * 算法描述: 
******************************************************************************/
FunError_t BinaryExchangeV1
	(
	 uint8_t *pSrc, 
	 const int32_t w, 
	 const int32_t h, 
	 const int32_t pitch,
	 const int32_t x0, 
	 const int32_t y0, 
	 const int32_t dx, 
	 const int32_t dy, 
	 const int32_t dir
	 );


#ifdef __cplusplus
}
#endif /* extern "C" */

#endif /* __IMAGE_BINARY_H */

