/******************************************************************************
 * 文件名：image_thining.h
 * 功  能：实现了主要的图像纹路的细化
******************************************************************************/
#if !defined __IMAGE_THINING_H
#define __IMAGE_THINING_H

/* 包含基本的图像操作函数 */
//#include "image_base.h"
#include "../../bsp/bsp_header/z_mytype.h"

//#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif


/******************************************************************************
  * 功能: 对图像进行条件细化及其改进算法,达到骨架化
  * 参数：pSrc			处理图像数据
  *		  width			图像数据宽度
  *		  height		图像数据高度
  *		  pitch			图像数据每行字节数
  * 返回：错误编号
  * 说明: 这里的条件细化条件不仅仅是条件细化算法的条件,还用了Pavlidis的条件,并进行了
  *		  条件细化算法的改进,即去除了第1,2类非单像素点
  * 算法描述：
  *          
  *          注意：前景是 "1",背景色是"0"。
  *
  *          1.条件细化算法；
  *          对p1点的8个邻域，如右图示需要满足以下四个条件，则删除p1点。
  *          ----------
  *          |p9|p2|p3|
  *          ----------
  *          |p8|p1|p4|
  *          ----------
  *          |p7|p6|p5|
  *          ----------
  *          (1)2<=N(p1)<=6;
  *          (2)S(p1)=1;
  *          (3)p2*p4*p6=0;
  *          (4)p4*p6*p8=0;
  *          
  *          2.条件细化算法
  *          1是一个方向，2.是另外一个方向
  *          (1)2<=N(p1)<=6;
  *          (2)S(p1)=1;
  *          (3)p2*p4*p8=0;
  *          (4)p2*p6*p8=0;
  *   
  *          其中： N(p1)为p1的8个邻域内非0邻点的个数。
  *                 S(p1)是以p2,p3,p4,p5,p6,p7,p8,p9,p2.为序扫描这些点时若它
  *                 们的值从0-1变化的次数。
  *
  *          (1)执行步骤1.对需要删除的点标记
  *          (2)删除做了标记的点
  *          (3)执行步骤2.对剩下的要删除的点进行标记。
  *          (4)删除有标记的点
  *          (5)反复进行(1)到(4)直到没有没有要删除的点。
  *
  *
  *          3.但是这一步得到的还不是 单像素点，还存在第一类和第二类非单像素
  *          点，其模板如下：
  *
  *          第一类：
  *
  *          -------     -------    -------    -------    
  *          |x|1|x|     |0|0|x|    |x|1|x|    |x|0|0|
  *          -------     -------    -------    -------
  *          |0|1|1|     |0|1|1|    |1|1|0|    |1|1|0|
  *          -------     -------    -------    -------
  *          |0|0|x|     |x|1|x|    |x|0|0|    |x|1|x|
  *          -------     -------    -------    -------
  *
  *          第二类：
  *
  *          -------     -------    -------    -------
  *          |x|1|x|     |x|0|x|    |x|1|x|    |x|1|x|
  *          -------     -------    -------    -------
  *          |0|1|1|     |1|1|1|    |1|1|0|    |1|1|1|
  *          -------     -------    -------    -------
  *          |x|1|x|     |x|1|x|    |x|1|x|    |x|0|x|
  *          -------     -------    -------    -------
  *          
  *          第二类条件总结为:p2+p4+p6+pp8=3;
  *         
  *
  *          执行完步骤1和2后，先进行第一类模板比较，删除满足条件的点，然后进行
  *          第二类模板的条件的比较然后删除满足条件的点。
  *         
  *          执行完1.,2.和3.后就可以得到单像素点的图像了。
******************************************************************************/
void ConditionThiningOZ
( 
 uint8_t *pSrc,
 const int32_t width, 
 const int32_t height, 
 const int32_t pitch
 );


/******************************************************************************
  * 功能: 对图像进行细化,骨架化
  * 参数：image            指向图像
  *       dir              扫描方向(0:左上->右下, 1:左下->右上)
  * 返回：错误编号
  * 算法描述：
  *
  * 注意: macro_image_scan_order应该是1或者是2
  *
  *         #define macro_image_scan_order 1 //表明扫描是从左上脚开始到右下角
  *         
  *         #define macro_image_scan_order 2 //表面扫描是从左下脚开始到右上角
  *
  *          注意：图像的前景是"1",背景是"0"
  *
  *          一个点p的8邻域如图所示
  *          ----------
  *          |x4|x3|x2|
  *          ----------
  *          |x5|p |x1|
  *          ----------
  *          |x6|x7|x8|
  *          ----------
  *          
  *          当p和它的领域同时满足以下6个条件时，则将其删除。
  *       
  *          (1) p为1，即p不是背景
  *          (2) x1,x3,x5,x7不全为1(若全为1时将它删除会导致图像空心)
  *          (3) x1到x8至少有两个为1.(若只有1个为1时是线段的端点，若没有为1
  *              时则是孤立点。
  *          (4) p的8联通连接数Nc8(p)为1
  *
  *          以下两个条件和图像的扫描顺序有关，
  *          当图像是从左上角开始，先从左向右扫描，然后从上向下扫描的顺序时，
  *          那么是(5)(6)
  *          当图像是从左下脚开始，先从左向右扫描，然后从下向上扫描的顺序时，
  *          那么是(7)(8)
  *          
  *          (5) 假设x3已经标记为删除，那么当x3为0时，p的8联通连结数为1
  *          (6) 假设x5已经标记为删除，那么当x5为0时，p的8联通连结数为1
  *
  *          (7) 假设x5已经标记为删除，那么当x5为0时，p的8联通连结数为1
  *          (8) 假设x7已经标记为删除，那么当x7为0时，p的8联通连结数为1
  *
  *                 4   
  *          Nc8(p)=【 (x~(2i-1)-x~(2i-1)*x~(2i)*x~(2i+1));
  *                 i=1
  *
  *          x~=1-x; 如：当i=1时，x~(2i-1)=x~1=1-x1; "【"是求和符号。
  *        
******************************************************************************/
void HilditchThiningOZ
( 
 uint8_t *pSrc,
 const int32_t dir,
 const int32_t width, 
 const int32_t height, 
 const int32_t pitch
 );


/************************************************************************
  * 功能：对图像数据使用查表法进行细化
  * 参数：pSrc				指向源图像数据区
  *		  width				图像数据宽度
  *		  height			图像数据高度
  *		  pitch				图像数据每行字节数
  *		  forecolor		    图像数据前景颜色
  *		  backcolor		    图像数据背景颜色
  *		  bina_type			图像二值类型1:(0,1)或其他:(0,255)
  * 返回：void
  * 说明: 有多种方法提取纹线的中心线,包括灰度最大梯度值连接提取,二值化细化提取
  *		  等,这里采用二值化细化中心线提取方法.
  *		  二值化细化提取中心线方法直观,方便,可靠,尤其是容易实现,提取速度快.
  *		  这种方法包括二值化和细化两个步骤
  *		  (1)二值化:二值化这个步骤有二值化函数(如OrientBinaryOZ)完成,经过
  *		     二值化的图像,只有两种灰度值,纹线的灰度值称为forecolor(前景色),
  *		     其他称为backcolor(背景色)
  *		  (2)细化:采用查表法.
  *			 查表法原理:对某一前景点(假设为黑色),如果它在图形边缘,
  *		                要去掉以实现细化,那么它的周围8点(8邻域)必定表现为一定的
  *						色彩顺序.在保持原图的骨架(细化要求)的前提下,人们根据
  *						8邻域的像素的各种情况,归纳出了一个"消除表",只要将8个像素
  *						从左至右,上至下的顺序一次作为二进制数的低位至高位得到的
  *						值即为索引值.如:
  *							0 0 1
  *							1 0 0
  *							0 0 1 则二进制为10001100=140
  *						根据索引值查找表,若对应的值为1,则这一点可以删除,反之保留
  *	算法: 1.利用查表法分别对水平和垂直方向进行细化
  *		    (1)水平方向:每找到一个点,计算8邻域的索引值,根据表查找是否要删除此点
  *						若是:则删除,同时将结束标志置位非结束状态.若否,保留此点
  *					    整幅图像数据的水平查找完毕一次则进行步骤(2)
  *						
  *		    (2)垂直方向:每找到一个点,计算8邻域的索引值,根据表查找是否要删除此点
  *						若是:则删除,同时将结束标志置位非结束状态.若否,保留此点
  *					    整幅图像数据的垂直查找完毕一次则:
  *						判断结束标志的状态,如果为非结束状态,则继续进行步骤(1)
  *						反之,结束细化.得到细化后的图像数据
  * 注意:输入图像数据为二值数据(0,1)或(0,255),且前景色必须为0???
*************************************************************************/
void ErasetableThining
(
 uint8_t *pSrc, 
 const int32_t width, 
 const int32_t height, 
 const int32_t pitch,
 const int32_t forecolor,
 const int32_t backcolor,
 const int32_t bina_type
);













#ifdef __cplusplus
}
#endif /* extern "C" */

#endif /* __IMAGE_THINING_H */
