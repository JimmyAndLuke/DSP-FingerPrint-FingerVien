/******************************************************************************
 * 文件名：image_thining.c
 * 功  能：实现了主要的图像纹路的细化
 * 说  明: 常见的细化算法:条件细化及其改进算法，Hildtch算法，OPTA细化算法、
 *		   基于数学形态学细化算法,Pavlidis算法，Rosenfeld算法,
 *		   旋转不变细化算法的细化规则
 *         其中串行算法:Hilditch
 *			   并行算法:OPTA细化,基于数学形态学细化,条件细化及其改进,Rosenfeld
 *			   串并算法:Pavlidis
 *		   并且,条件细化和pavlidis是很相似的.
******************************************************************************/
#include "dip_header/image_thining.h"
//#include "../../bsp/bsp_header/z_mytype.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

/******************************************************************************
  * 功能: 对图像进行条件细化及其改进算法,达到骨架化
  * 参数：pSrc			处理前图像数据
  *		  width			图像数据宽度
  *		  height		图像数据高度
  *		  pitch			图像数据每行字节数
  * 返回：错误编号
  * 说明: 这里的条件细化条件不仅仅是条件细化算法的条件,还用了Pavlidis的条件,并进行了
  *		  条件细化算法的改进,即去除了第1,2类非单像素点
  * 算法描述：
  *          
  *          注意：前景是 "1",背景色是"0"。
  *
  *          1.条件细化算法；
  *          对p1点的8个邻域，如右图示需要满足以下四个条件，则删除p1点。
  *          ----------
  *          |p9|p2|p3|
  *          ----------
  *          |p8|p1|p4|
  *          ----------
  *          |p7|p6|p5|
  *          ----------
  *          (1)2<=N(p1)<=6;
  *          (2)S(p1)=1;
  *          (3)p2*p4*p6=0;
  *          (4)p4*p6*p8=0;
  *          
  *          2.条件细化算法
  *          1是一个方向，2.是另外一个方向
  *          (1)2<=N(p1)<=6;
  *          (2)S(p1)=1;
  *          (3)p2*p4*p8=0;
  *          (4)p2*p6*p8=0;
  *   
  *          其中： N(p1)为p1的8个邻域内非0邻点的个数。
  *                 S(p1)是以p2,p3,p4,p5,p6,p7,p8,p9,p2.为序扫描这些点时若它
  *                 们的值从0-1变化的次数。
  *
  *          (1)执行步骤1.对需要删除的点标记
  *          (2)删除做了标记的点
  *          (3)执行步骤2.对剩下的要删除的点进行标记。
  *          (4)删除有标记的点
  *          (5)反复进行(1)到(4)直到没有没有要删除的点。
  *
  *
  *          3.但是这一步得到的还不是 单像素点，还存在第一类和第二类非单像素
  *          点，其模板如下：
  *
  *          第一类：
  *
  *          -------     -------    -------    -------    
  *          |x|1|x|     |0|0|x|    |x|1|x|    |x|0|0|
  *          -------     -------    -------    -------
  *          |0|1|1|     |0|1|1|    |1|1|0|    |1|1|0|
  *          -------     -------    -------    -------
  *          |0|0|x|     |x|1|x|    |x|0|0|    |x|1|x|
  *          -------     -------    -------    -------
  *
  *          第二类：
  *
  *          -------     -------    -------    -------
  *          |x|1|x|     |x|0|x|    |x|1|x|    |x|1|x|
  *          -------     -------    -------    -------
  *          |0|1|1|     |1|1|1|    |1|1|0|    |1|1|1|
  *          -------     -------    -------    -------
  *          |x|1|x|     |x|1|x|    |x|1|x|    |x|0|x|
  *          -------     -------    -------    -------
  *          
  *          第二类条件总结为:p2+p4+p6+pp8=3;
  *         
  *
  *          执行完步骤1和2后，先进行第一类模板比较，删除满足条件的点，然后进行
  *          第二类模板的条件的比较然后删除满足条件的点。
  *         
  *          执行完1.,2.和3.后就可以得到单像素点的图像了。
******************************************************************************/
void ConditionThiningOZ
( 
 uint8_t *pSrc,
 const int32_t width, 
 const int32_t height, 
 const int32_t pitch
 )
{
#undef  PSRC	
#define PSRC(x, y)		pSrc[(x)+(y)*pitch]
	int32_t x,y;
	int32_t p2,p3,p4,p5,p6,p7,p8,p9;
	int32_t Np1;
	int32_t Sp1;
	int32_t t_h,t_w;
	int32_t flagcnt;//当前删除点的个数。
	int32_t exitflag;//退出标记
    int32_t runcnt=0;

	//int32_t w       = ImageGetWidth(image);
 //   int32_t h       = ImageGetHeight(image);
 //   int32_t pitch   = ImageGetPitch(image);
 //   uint8_t* p     = ImageGetBuffer(image);
	
	t_h=height-1;
	t_w=width-1;

	do{
		flagcnt=0;
		exitflag=0;
        runcnt++;

		//第一次标记
		for (y=1;y<t_h;y++) {
			for (x=1;x<t_w;x++) {			  
				//背景点舍去
				if(PSRC(x, y)==0) {
					continue;
				}
				//与0x01做&运算,巧妙的利用了做标记时使点的值为3的特点
				//与ImageSkeletonBurrMarkOZ函数里面对标记的处理有异曲同工之妙
                p2=PSRC(x  , y+1)&0x01; //p2
				p3=PSRC(x+1, y+1)&0x01; //p3
				p4=PSRC(x+1, y  )&0x01; //p4
				p5=PSRC(x+1, y-1)&0x01; //p5
                p6=PSRC(x  , y-1)&0x01; //p6
                p7=PSRC(x-1, y-1)&0x01; //p7
				p8=PSRC(x-1, y  )&0x01; //p8
				p9=PSRC(x-1, y+1)&0x01; //p9

                //(1)2<=N(p1)<=6
               Np1=p2+p3+p4+p5+p6+p7+p8+p9;
			   if(Np1<2||Np1>6){
				   continue;
			   }

               //(2)S(p1)=1
			   //Sp1=abs(p2-p3)+\
				  // abs(p3-p4)+\
				  // abs(p4-p5)+\
				  // abs(p5-p6)+\
				  // abs(p6-p7)+\
				  // abs(p7-p8)+\
				  // abs(p8-p9)+\
				  // abs(p9-p2);
			   //if(Sp1!=2){
				  // continue;
			   //}
			   //这一步运算简化为下面这步
			   Sp1=(p2&p3)+(p3&p4)+\
				   (p4&p5)+(p5&p6)+\
				   (p6&p7)+(p7&p8)+\
				   (p8&p9)+(p9&p2)+ 1 ;
			   if(Sp1!=Np1){
				   continue;
			   }
               
			   //(3)p2*p4*p6=0;
			   if(p2*p4*p6!=0){
				   continue;
			   }

			   //(4)p4*p6*p8=0;
		       if(p4*p6*p8!=0){
				   continue;
			   }

               PSRC(x, y)=3; //标记,巧妙利用了3这个数
               flagcnt++;
			}//end for (j=1...
		}//end for(i=1...
        
		//第一次删除:删除标记点
		if(flagcnt==0) {
			exitflag++;
			//break;
		} else {
			for(y=0;y<height;y++){
				for(x=0;x<width;x++){
					PSRC(x, y)=((PSRC(x, y)==1)?1:0);
				}//for (j=0...
			}//for (i=0...
		}//end else

		//第二次标记
       for(y=1;y<t_h;y++){
			for(x=1;x<t_w;x++){
			  
				//背景点舍去
				if(PSRC(x, y)==0){
					continue;
				}
				//与0x01做&运算,巧妙的利用了做标记时使点的值为3的特点
                p2=PSRC(x  , y+1)&0x01; //p2
				p3=PSRC(x+1, y+1)&0x01; //p3
				p4=PSRC(x+1, y  )&0x01; //p4
				p5=PSRC(x+1, y-1)&0x01; //p5
                p6=PSRC(x  , y-1)&0x01; //p6
                p7=PSRC(x-1, y-1)&0x01; //p7
				p8=PSRC(x-1, y  )&0x01; //p8
				p9=PSRC(x-1, y+1)&0x01; //p9

                //(1)2<=N(p1)<=6
               Np1=p2+p3+p4+p5+p6+p7+p8+p9;
			   if(Np1<2||Np1>6){
				   continue;
			   }

               //(2)S(p1)=1
			   //Sp1=abs(p2-p3)+\
				  // abs(p3-p4)+\
				  // abs(p4-p5)+\
				  // abs(p5-p6)+\
				  // abs(p6-p7)+\
				  // abs(p7-p8)+\
				  // abs(p8-p9)+\
				  // abs(p9-p2);
			   //if(Sp1!=2){
				  // continue;
			   //}
			   //这一步运算简化为下面这步
			   Sp1=(p2&p3)+(p3&p4)+\
				   (p4&p5)+(p5&p6)+\
				   (p6&p7)+(p7&p8)+\
				   (p8&p9)+(p9&p2)+ 1 ;
			   if(Sp1!=Np1){
				   continue;
			   }
               
			   //(3)p2*p4*p6=0;
			   if(p2*p4*p8!=0){
				   continue;
			   }

			   //(4)p4*p6*p8=0;
		       if(p2*p6*p8!=0){
				   continue;
			   }

               PSRC(x, y)=3; //标记,巧妙利用了3这个数
               flagcnt++;
			}//end for (j=1...
		}//end for(i=1...
        
		//第二次删除:删除标记点
		if(flagcnt==0&&exitflag==1){
			break;
		}else{
			for(y=0;y<height;y++){
				for(x=0;x<width;x++){
					//这个地方还是加上括号,不加的时候出错了
					PSRC(x, y)=((PSRC(x, y)==1)?1:0);
				}//for (j=0...
			}//for (i=0...
		}//end else

	}while(1);
	//标记,删除完毕
	//开始清除异点
	//清除第一类异点
	for(y=1;y<t_h;y++){
		for(x=1;x<t_w;x++){

			//背景点舍去
			if(PSRC(x, y)==0){
				continue;
			}
			//与0x01做&运算,巧妙的利用了做标记时使点的值为3的特点                    
            p2=PSRC(x  , y+1)&0x01; //p2
			p3=PSRC(x+1, y+1)&0x01; //p3
			p4=PSRC(x+1, y  )&0x01; //p4
			p5=PSRC(x+1, y-1)&0x01; //p5
            p6=PSRC(x  , y-1)&0x01; //p6
            p7=PSRC(x-1, y-1)&0x01; //p7
			p8=PSRC(x-1, y  )&0x01; //p8
			p9=PSRC(x-1, y+1)&0x01; //p9

			if((p2*p4)==1&&(p6+p7+p8)==0){
				PSRC(x,y)=0;
				continue;
			}
			if((p4*p6)==1&&(p8+p9+p2)==0){
				PSRC(x,y)=0;
				continue;
			} 
			if((p8*p2)==1&&(p4+p5+p6)==0){
				PSRC(x,y)=0;
				continue;
			}
			if((p6*p8)==1&&(p2+p3+p4)==0){
				PSRC(x,y)=0;
				continue;
			}//end if
		}//end for(j=1...
	}//end for(i=1...
    
   //清除第二类异点
	for(y=1;y<t_h;y++){
		for(x=1;x<t_w;x++){
			
			//背景点舍去
			if(PSRC(x,y)!=1){
				continue;
			}

            //         rows  cols
            p2=PSRC(x  , y+1)&0x01; //p2
			p3=PSRC(x+1, y+1)&0x01; //p3
			p4=PSRC(x+1, y  )&0x01; //p4
			p5=PSRC(x+1, y-1)&0x01; //p5
            p6=PSRC(x  , y-1)&0x01; //p6
            p7=PSRC(x-1, y-1)&0x01; //p7
			p8=PSRC(x-1, y  )&0x01; //p8
			p9=PSRC(x-1, y+1)&0x01; //p9

			if(p2+p4+p6+p8==3){
				PSRC(x, y)=0;
			}//end if
		}//end for(j=1...
	}//end for(i=1...

	
}

/******************************************************************************
  * 功能: 对图像进行细化,骨架化
  * 参数：image            指向图像
  *       dir              扫描方向(0:左上->右下, 1:左下->右上)
  * 返回：错误编号
  * 算法描述：
  *
  * 注意: macro_image_scan_order应该是1或者是2
  *
  *         #define macro_image_scan_order 1 //表明扫描是从左上脚开始到右下角
  *         
  *         #define macro_image_scan_order 2 //表面扫描是从左下脚开始到右上角
  *
  *          注意：图像的前景是"1",背景是"0"
  *
  *          一个点p的8邻域如图所示
  *          ----------
  *          |x4|x3|x2|
  *          ----------
  *          |x5|p |x1|
  *          ----------
  *          |x6|x7|x8|
  *          ----------
  *          
  *          当p和它的领域同时满足以下6个条件时，则将其删除。
  *       
  *          (1) p为1，即p不是背景
  *          (2) x1,x3,x5,x7不全为1(若全为1时将它删除会导致图像空心)
  *          (3) x1到x8至少有两个为1.(若只有1个为1时是线段的端点，若没有为1
  *              时则是孤立点。
  *          (4) p的8联通连接数Nc8(p)为1
  *
  *          以下两个条件和图像的扫描顺序有关，
  *          当图像是从左上角开始，先从左向右扫描，然后从上向下扫描的顺序时，
  *          那么是(5)(6)
  *          当图像是从左下脚开始，先从左向右扫描，然后从下向上扫描的顺序时，
  *          那么是(7)(8)
  *          
  *          (5) 假设x3已经标记为删除，那么当x3为0时，p的8联通连结数为1
  *          (6) 假设x5已经标记为删除，那么当x5为0时，p的8联通连结数为1
  *
  *          (7) 假设x5已经标记为删除，那么当x5为0时，p的8联通连结数为1
  *          (8) 假设x7已经标记为删除，那么当x7为0时，p的8联通连结数为1
  *
  *                 4   
  *          Nc8(p)=【 (x~(2i-1)-x~(2i-1)*x~(2i)*x~(2i+1));
  *                 i=1
  *
  *          x~=1-x; 如：当i=1时，x~(2i-1)=x~1=1-x1; "【"是求和符号。
  *        
******************************************************************************/
//void HilditchThiningOZ
//( 
// uint8_t *pSrc,
// const int32_t dir,
// const int32_t width, 
// const int32_t height, 
// const int32_t pitch
// )
//{
//#undef  PSRC	
//#define PSRC(x, y)		pSrc[(x)+(y)*pitch]
//	int32_t x,y;
//	int32_t x1,x2,x3,x4,x5,x6,x7,x8; 
//	int32_t flagcnt;    //标记计数。
//	int32_t loopcnt;  //循环计数，认为一开始就是1.
//    int32_t Ncp8;       //8联通连结数
//	int32_t t_h ,t_w;
//
//	loopcnt=1;
//	t_h=height-1;
//	t_w=width-1;
//	do{
//		loopcnt++;
//		flagcnt=0;
//
//		for(y=1;y<t_h;y++){
//			for(x=1;x<t_w;x++){
//            
//				//(1)p不为背景
//				if(PSRC(x, y)==0){
//					continue;
//				}
//
//                x1=PSRC(x+1, y  )&0x01; //x1
//		        x2=PSRC(x+1, y+1)&0x01; //x2
//		        x3=PSRC(x  , y+1)&0x01; //x3
//			    x4=PSRC(x-1, y+1)&0x01; //x4
//                x5=PSRC(x-1, y  )&0x01; //x5
//                x6=PSRC(x-1, y-1)&0x01; //x6
//		        x7=PSRC(x  , y-1)&0x01; //x7
//			    x8=PSRC(x+1, y-1)&0x01; //x8
//	
//                //(2) x1,x3,x5,x7不全为1
//				if((x1&x3&x5&x7)==1){
//					continue;
//				}
//				//(3) x1到x8至少有两个为1
//				if((x1+x2+x3+x4+x5+x6+x7+x8)<2){
//					continue;
//				}
//				//(4) p的8联通连接数Nc8(p)为1
//                x1=1-x1;
//				x2=1-x2;
//				x3=1-x3;
//				x4=1-x4;
//				x5=1-x5;
//				x6=1-x6;
//				x7=1-x7;
//				x8=1-x8;
//				Ncp8=(x1+x3+x5+x7)-(x1*x2*x3+x3*x4*x5+x5*x6*x7+x7*x8*x1);
//				if(Ncp8!=1){
//					continue;
//				}
//               
//				//以下两步和扫描顺序有关
//
//				/*当扫描顺序为从左上角到右下角时*/
////#if  macro_image_scan_order==1
//				if (dir == 0) {
//					//判断x3是否被标记
//					if(PSRC(x, y+1)==0x03){
//						x3=1; //
//						Ncp8=(x1+x3+x5+x7)-(x1*x2*x3+x3*x4*x5+x5*x6*x7+x7*x8*x1);
//						x3=0;
//						if(Ncp8!=1){
//							continue;
//						}
//					}
//	                
//					//判断x5是否被标记
//					if(PSRC(x-1, y)==0x03){
//						x5=1;
//						Ncp8=(x1+x3+x5+x7)-(x1*x2*x3+x3*x4*x5+x5*x6*x7+x7*x8*x1);
//						if(Ncp8!=1){
//							continue;
//						}
//					}
//				}
////#elif macro_image_scan_order==2
//				else {
//					//判断x5是否被标记
//					if(PSRC(x-1, y)==0x03){
//						x5=1;
//						Ncp8=(x1+x3+x5+x7)-(x1*x2*x3+x3*x4*x5+x5*x6*x7+x7*x8*x1);
//						x5=0;
//						if(Ncp8!=1){
//							continue;
//						}
//					}
//
//					//判断x7是否被标记
//					if(PSRC(x, y-1)==0x03){
//						x7=1;
//						Ncp8=(x1+x3+x5+x7)-(x1*x2*x3+x3*x4*x5+x5*x6*x7+x7*x8*x1);
//						if(Ncp8!=1){
//							continue;
//						}
//					}
//				}
////#elif  (macro_image_scan_order<1)||(macro_iamge_scan_order>2)
////#error pixel_hilditch_thin : macro_image_scan_order must be define equal to 1 or 2
////#endif
//
//				//到这里所有条件都已经满足了，标记该点。
//				PSRC(x, y)=0x03;
//
//				flagcnt++;//标记数一
//
//			}//end for(j=1...
//		}//end for (i=1...
//
//		if(flagcnt==0){
//			break;
//		}else{
//			for(y=1;y<t_h;y++){
//				for(x=1;x<t_w;x++){
//					PSRC(x, y)=PSRC(x, y)==1?1:0;
//				}//end for (j=1...
//			}//end for (i=1...
//		}//end else
//            
//	}while(1);
//
//}







//归纳出来的索引表
//索引值计算:(图像像素值只有0,1两种)
//邻域点定义如下:
//	9 2 3		//p9	p2	 p3
//  8 1 4		//p8	o	 p4
//  7 6 5		//p7	p6	 p5
//index = p5*128 + p6*64 + p7*32 + p4*16 + p8*8  + p3*4  + p2*2  +p9;
//      = (p5<<7)|(p6<<6)|(p7<<5)|(p4<<4)|(p8<<3)|(p3<<2)|(p2<<1)|p9;
uint8_t  erasetable[256]={
			0,0,1,1,0,0,1,1,             1,1,0,1,1,1,0,1,
			1,1,0,0,1,1,1,1,             0,0,0,0,0,0,0,1,
			0,0,1,1,0,0,1,1,             1,1,0,1,1,1,0,1,
			1,1,0,0,1,1,1,1,             0,0,0,0,0,0,0,1,
			1,1,0,0,1,1,0,0,             0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,             0,0,0,0,0,0,0,0,
			1,1,0,0,1,1,0,0,             1,1,0,1,1,1,0,1,
			0,0,0,0,0,0,0,0,             0,0,0,0,0,0,0,0,
			0,0,1,1,0,0,1,1,             1,1,0,1,1,1,0,1,
			1,1,0,0,1,1,1,1,             0,0,0,0,0,0,0,1,
			0,0,1,1,0,0,1,1,             1,1,0,1,1,1,0,1,
			1,1,0,0,1,1,1,1,             0,0,0,0,0,0,0,0,
			1,1,0,0,1,1,0,0,             0,0,0,0,0,0,0,0,
			1,1,0,0,1,1,1,1,             0,0,0,0,0,0,0,0,
			1,1,0,0,1,1,0,0,             1,1,0,1,1,1,0,0,
			1,1,0,0,1,1,1,0,             1,1,0,0,1,0,0,0
	};

/************************************************************************
  * 功能：对图像数据使用查表法进行细化
  * 参数：pSrc				指向源图像数据区
  *		  width				图像数据宽度
  *		  height			图像数据高度
  *		  pitch				图像数据每行字节数
  *		  forecolor		    图像数据前景颜色
  *		  backcolor		    图像数据背景颜色
  *		  bina_type			图像二值类型1:(0,1)或其他:(0,255)
  * 返回：void
  * 说明: 有多种方法提取纹线的中心线,包括灰度最大梯度值连接提取,二值化细化提取
  *		  等,这里采用二值化细化中心线提取方法.
  *		  二值化细化提取中心线方法直观,方便,可靠,尤其是容易实现,提取速度快.
  *		  这种方法包括二值化和细化两个步骤
  *		  (1)二值化:二值化这个步骤有二值化函数(如OrientBinaryOZ)完成,经过
  *		     二值化的图像,只有两种灰度值,纹线的灰度值称为forecolor(前景色),
  *		     其他称为backcolor(背景色)
  *		  (2)细化:采用查表法.
  *			 查表法原理:对某一前景点(假设为黑色),如果它在图形边缘,
  *		                要去掉以实现细化,那么它的周围8点(8邻域)必定表现为一定的
  *						色彩顺序.在保持原图的骨架(细化要求)的前提下,人们根据
  *						8邻域的像素的各种情况,归纳出了一个"消除表",只要将8个像素
  *						从左至右,上至下的顺序一次作为二进制数的低位至高位得到的
  *						值即为索引值.如:
  *							0 0 1
  *							1 0 0
  *							0 0 1 则二进制为10001100=140
  *						根据索引值查找表,若对应的值为1,则这一点可以删除,反之保留
  *	算法: 1.利用查表法分别对水平和垂直方向进行细化
  *		    (1)水平方向:每找到一个点,计算8邻域的索引值,根据表查找是否要删除此点
  *						若是:则删除,同时将结束标志置位非结束状态.若否,保留此点
  *					    整幅图像数据的水平查找完毕一次则进行步骤(2)
  *						
  *		    (2)垂直方向:每找到一个点,计算8邻域的索引值,根据表查找是否要删除此点
  *						若是:则删除,同时将结束标志置位非结束状态.若否,保留此点
  *					    整幅图像数据的垂直查找完毕一次则:
  *						判断结束标志的状态,如果为非结束状态,则继续进行步骤(1)
  *						反之,结束细化.得到细化后的图像数据
  * 注意:输入图像数据为二值数据(0,1)或(0,255),且前景色必须为0???
*************************************************************************/
void ErasetableThining
(
 uint8_t *pSrc, 
 const int32_t width, 
 const int32_t height, 
 const int32_t pitch,
 const int32_t forecolor,
 const int32_t backcolor,
 const int32_t bina_type
)
{
	int32_t	x,y;
	int32_t num;
	int32_t finished;
	
	//邻域点定义如下:
	//	9 2 3		//p9	p2	 p3
	//  8 1 4		//p8	o	 p4
	//  7 6 5		//p7	p6	 p5
	uint8_t p9,p2,p3,p8,p4,p7,p6,p5;
	//uint8_t *pFPTemp = NULL;
	uint8_t *pS = NULL;
	//uint8_t *pT = NULL;	

	//memcpy((void *)pFPTemp, (void *)pSrc, width*height);
	//pFPTemp = (uint8_t *)malloc(sizeof(uint8_t)*width*height);
	//memcpy(pFPTemp, pSrc, sizeof(uint8_t)*width*height);

	//结束标志置成假
	finished=0;
	while(!finished){		//还没有结束
        finished=1;			//结束标志置成假

        //先进行水平方向的细化
		for (y=1;y<height-1;y++) {	 //注意为防止越界，y的范围从1到height-2	   
			x=1;					//注意为防止越界，x的范围从1到width-2

			//pS指向原图数据，pT指向新图数据
			pS=(uint8_t *)pSrc+y*width;
			//pT=(uint8_t *)pFPTemp+y*width;

			while (x < width-1) {
				
				//是黑点才做处理(前景为黑色,即纹路在二值化时没有反向)
				//if(*(pS+x) == 0) { 
				if(*(pS+x) == forecolor) { 
				   p8 = *(pS+x-1);  //左邻点
				   p4 = *(pS+x+1);  //右邻点

				   //如果左右两个邻居中至少有一个是白点才处理
				   //if((p8 == 255) || (p4 == 255)) {
				   if((p8 == backcolor) || (p4 == backcolor)) {
					   p9=*(pS+x+width-1);	//左上邻点	  
					   p2=*(pS+x+width);	//上邻点				  
					   p3=*(pS+x+width+1);	//右上邻点		  
					   p7=*(pS+x-width-1);	//左下邻点				  
					   p6=*(pS+x-width);	//下邻点		  
					   p5=*(pS+x-width+1);	//右下邻点

					   //根据二值类型计算索引
					   if (bina_type == 1)		//0,1二值
						   num = (p5<<7)|(p6<<6)|(p7<<5)|(p4<<4)|(p8<<3)|(p3<<2)|(p2<<1)|p9;			  
					   else						//0,255二值
						   num=p9/255+p2/255*2+p3/255*4+p8/255*8+p4/255*16+p7/255*32+p6/255*64+p5/255*128;
					   
					   if(erasetable[num]==1) { //经查表，可以删除				
						   //*(pS+x)=255; 		//在原图缓冲区中将该黑点删除
						   //*(pT+x)=255;		//结果图中该黑点也删除
						   *(pS+x)=backcolor; 	//在原图缓冲区中将该黑点删除
						  // *(pT+x)=backcolor;	//结果图中该黑点也删除
						   finished=0;			//有改动，结束标志置成假
						   x++;					//水平方向跳过一个象素		   
					   }
				   }
				}
				x++; //扫描下一个象素
			}
		}

		//再进行垂直方向的细化
		for (x=1;x<width-1;x++) {	//注意为防止越界，x的范围从1到width-2         
			y=1;					//注意为防止越界，y的范围从1到height-2           
			while(y<height-1) {                
				pS=pSrc+y*width;         
				//pT=pFPTemp+y*width;

				//if(*(pS+x) == 0) { //是黑点才做处理  
				if(*(pS+x) == forecolor) { //是黑点才做处理                       
					p2=*(pS+x+width);     
					p6=*(pS+x-width);

					//如果上下两个邻居中至少有一个是白点才处理
					//if( (p2==255)|| (p6==255)){
					if((p2==backcolor)|| (p6==backcolor)) {
						p9=*(pS+x+width-1);                      
						p3=*(pS+x+width+1);               
						p8=*(pS+x-1);                  
						p4=*(pS+x+1);               
						p7=*(pS+x-width-1);                   
						p5=*(pS+x-width+1);
                          
						//根据二值类型计算索引							
						if (bina_type == 1)		//0,1二值
							num = (p5<<7)|(p6<<6)|(p7<<5)|(p4<<4)|(p8<<3)|(p3<<2)|(p2<<1)|p9;			  
						else					//0,255二值
							num=p9/255+p2/255*2+p3/255*4+p8/255*8+p4/255*16+p7/255*32+p6/255*64+p5/255*128;

						if(erasetable[num]==1) {//经查表，可以删除               
							//*(pS+x)=255;		//在原图缓冲区中将该黑点删除
							//*(pT+x)=255;		//结果图中该黑点也删除
							*(pS+x)=backcolor;	//在原图缓冲区中将该黑点删除
							//*(pT+x)=backcolor;	//结果图中该黑点也删除  
							finished=0;			//有改动，结束标志置成假
							y++;				//垂直方向跳过一个象素
						}             
					}         
				}   
				y++; //扫描下一个象素
			}
		} 

	}
	
	//memcpy(pSrc, pFPTemp, sizeof(uint8_t)*width*height);

	//if (pFPTemp != NULL) {
	//	free(pFPTemp);
	//	pFPTemp = NULL;
	//}
}

























